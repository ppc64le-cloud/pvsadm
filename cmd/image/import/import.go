// Copyright 2021 IBM Corp
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package _import

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/IBM-Cloud/bluemix-go/api/resource/resourcev1/controller"
	"github.com/IBM-Cloud/bluemix-go/api/resource/resourcev2/controllerv2"
	"github.com/IBM-Cloud/bluemix-go/crn"
	"github.com/IBM-Cloud/bluemix-go/models"
	pmodels "github.com/IBM-Cloud/power-go-client/power/models"
	"github.com/spf13/cobra"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/klog/v2"

	"github.com/ppc64le-cloud/pvsadm/pkg"
	"github.com/ppc64le-cloud/pvsadm/pkg/client"
	"github.com/ppc64le-cloud/pvsadm/pkg/utils"
)

const (
	serviceCredPrefix = "pvsadm-service-cred"
)

// Find COSINSTANCE details of the Provided bucket
func findCOSInstanceDetails(resources []models.ServiceInstanceV2, bxCli *client.Client) (string, string, crn.CRN) {
	for _, resource := range resources {
		if resource.Crn.ServiceName == "cloud-object-storage" {
			s3client, err := client.NewS3Client(bxCli, resource.Name, pkg.ImageCMDOptions.Region)
			if err != nil {
				continue
			}
			buckets, err := s3client.S3Session.ListBuckets(nil)
			if err != nil {
				continue
			}
			for _, bucket := range buckets.Buckets {
				if *bucket.Name == pkg.ImageCMDOptions.BucketName {
					return resource.Name, resource.Guid, resource.Crn
				}
			}
		}
	}
	return "", "", crn.CRN{}
}

var Cmd = &cobra.Command{
	Use:   "import",
	Short: "Import the image into PowerVS instances",
	Long: `Import the image into PowerVS instances
pvsadm image import --help for information

# Set the API key or feed the --api-key commandline argument
export IBMCLOUD_API_KEY=<IBM_CLOUD_API_KEY>

# To Import the imge across the two different IBM account use accesskey and secretkey options

# To Import the image from public bucket use public-bucket option

Examples:

# import image using default storage type (service credential will be autogenerated)
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION>

# import image using default storage type with specifying the accesskey and secretkey explicitly
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --accesskey <ACCESSKEY> --secretkey <SECRETKEY> --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION>

# with user provided storage type
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --pvs-storagetype <STORAGETYPE> --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION>

# If user wants to specify the type of OS
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME> --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION>

# import image from a public IBM Cloud Storage bucket
pvsadm image import -n upstream-core-lon04 -b <BUCKETNAME>  --object rhel-83-10032020.ova.gz --pvs-image-name test-image -r <REGION> --public-bucket
`,
	PreRunE: func(cmd *cobra.Command, args []string) error {
		if pkg.ImageCMDOptions.InstanceID == "" && pkg.ImageCMDOptions.InstanceName == "" {
			return fmt.Errorf("--pvs-instance-name or --pvs-instance-id required")
		}

		case1 := pkg.ImageCMDOptions.AccessKey == "" && pkg.ImageCMDOptions.SecretKey != ""
		case2 := pkg.ImageCMDOptions.AccessKey != "" && pkg.ImageCMDOptions.SecretKey == ""

		if case1 || case2 {
			return fmt.Errorf("required both --accesskey and --secretkey values")
		}
		return nil
	},

	RunE: func(cmd *cobra.Command, args []string) error {
		opt := pkg.ImageCMDOptions
		apikey := pkg.Options.APIKey
		//validate inputs
		validStorageType := []string{"tier3", "tier1"}

		if !utils.Contains(validStorageType, strings.ToLower(opt.StorageType)) {
			klog.Errorf("Provide valid StorageType.. allowable values are [tier1, tier3]")
			os.Exit(1)
		}

		bxCli, err := client.NewClientWithEnv(apikey, pkg.Options.Environment, pkg.Options.Debug)
		if err != nil {
			return err
		}

		//Create AccessKey and SecretKey for the bucket provided if bucket access is private
		if (opt.AccessKey == "" || opt.SecretKey == "") && (!opt.Public) {
			//Find CosInstance of the bucket
			var svcs []models.ServiceInstanceV2
			svcs, err = bxCli.ResourceClientV2.ListInstances(controllerv2.ServiceInstanceQuery{
				Type: "service_instance",
			})
			if err != nil {
				return err
			}
			cosInstanceName, cosID, crn := findCOSInstanceDetails(svcs, bxCli)
			if cosInstanceName == "" {
				return fmt.Errorf("failed to find the COS instance for the bucket mentioned: %s", opt.BucketName)
			}

			keys, err := bxCli.GetResourceKeys(cosID)
			if err != nil {
				return fmt.Errorf("failed to list the service credentials: %v", err)
			}

			var cred map[string]interface{}
			var ok bool
			if len(keys) == 0 {
				if opt.ServiceCredName == "" {
					opt.ServiceCredName = serviceCredPrefix + "-" + cosInstanceName
				}

				// Create the service credential if does not exist
				klog.Infof("Auto Generating the COS Service credential for importing the image with name: %s", opt.ServiceCredName)
				CreateServiceKeyRequest := controller.CreateServiceKeyRequest{
					Name:       opt.ServiceCredName,
					SourceCRN:  crn,
					Parameters: map[string]interface{}{"HMAC": true},
				}
				newKey, err := bxCli.ResourceServiceKey.CreateKey(CreateServiceKeyRequest)
				if err != nil {
					return err
				}
				cred, ok = newKey.Credentials["cos_hmac_keys"].(map[string]interface{})
			} else {
				// Use the service credential already created
				klog.Infof("Reading the existing service credential")
				cred, ok = keys[0].Credentials["cos_hmac_keys"].(map[string]interface{})
			}
			if !ok {
				return fmt.Errorf("failed to get the accessKey and secretKey from service credential")
			}
			//Assign the Access Key and Secret Key for further operation
			opt.AccessKey = cred["access_key_id"].(string)
			opt.SecretKey = cred["secret_access_key"].(string)
		}

		pvmclient, err := client.NewPVMClientWithEnv(bxCli, opt.InstanceID, opt.InstanceName, pkg.Options.Environment)
		if err != nil {
			return err
		}
		//By default Bucket Access is private
		bucketAccess := "private"

		if opt.Public {
			bucketAccess = "public"
		}
		jobRef, err := pvmclient.ImgClient.ImportImage(opt.ImageName, opt.ImageFilename, opt.Region,
			opt.AccessKey, opt.SecretKey, opt.BucketName, strings.ToLower(opt.StorageType), bucketAccess)
		if err != nil {
			return err
		}

		start := time.Now()
		pollErr := wait.PollImmediate(2*time.Minute, opt.WatchTimeout, func() (bool, error) {
			job, err := pvmclient.JobClient.Get(*jobRef.ID)
			if err != nil {
				return false, err
			}
			if *job.Status.State == "completed" {
				return true, nil
			}
			if *job.Status.State == "failed" {
				return false, fmt.Errorf("image import job failed to complete, err: %v", job.Status.Message)
			}
			klog.Infof("Image Import Job in-progress, current state: %s", *job.Status.State)
			return false, nil
		})
		if pollErr == wait.ErrWaitTimeout {
			pollErr = fmt.Errorf("timed out while waiting for image import job to complete")
		}

		if pollErr != nil {
			return fmt.Errorf("image import job failed to complete, err: %v", pollErr)
		}

		var image *pmodels.ImageReference = &pmodels.ImageReference{}
		for image.ImageID == nil {
			image, err = pvmclient.ImgClient.GetImageByName(opt.ImageName)
			if err != nil {
				return err
			}
			klog.Infof("Retriving image details")
		}

		if !opt.Watch {
			klog.Infof("Importing Image %s is currently in %s state, Please check the Progress in the IBM Cloud UI\n", *image.Name, *image.State)
			return nil
		}

		pollErr = wait.PollImmediate(2*time.Minute, opt.WatchTimeout, func() (bool, error) {
			img, err := pvmclient.ImgClient.Get(*image.ImageID)
			if err != nil {
				return false, err
			}
			if img.State == "active" {
				return true, nil
			}
			klog.Infof("Import in-progress, current state: %s", img.State)
			return false, nil
		})
		if pollErr == wait.ErrWaitTimeout {
			pollErr = fmt.Errorf("timed out while waiting for image to become ready state")
		}

		if pollErr != nil {
			return fmt.Errorf("failed to import the image, err: %v\n\nRun this command to get more information for the failure: pvsadm get events -i %s", pollErr, pvmclient.InstanceID)
		}

		klog.Infof("Successfully imported the image: %s with ID: %s within %s", *image.Name, *image.ImageID, time.Since(start))

		return nil
	},
}

func init() {
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.InstanceName, "pvs-instance-name", "n", "", "PowerVS Instance name.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.InstanceID, "pvs-instance-id", "i", "", "PowerVS Instance ID.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.BucketName, "bucket", "b", "", "Cloud Object Storage bucket name.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.COSInstanceName, "cos-instance-name", "s", "", "Cloud Object Storage instance name.")
	// TODO It's deprecated and will be removed in a future release
	Cmd.Flags().MarkDeprecated("cos-instance-name", "will be removed in a future version.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.Region, "bucket-region", "r", "", "Cloud Object Storage bucket location.")
	Cmd.Flags().StringVarP(&pkg.ImageCMDOptions.ImageFilename, "object", "o", "", "Cloud Object Storage object name.")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.AccessKey, "accesskey", "", "Cloud Object Storage HMAC access key.")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.SecretKey, "secretkey", "", "Cloud Object Storage HMAC secret key.")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.ImageName, "pvs-image-name", "", "Name to PowerVS imported image.")
	Cmd.Flags().BoolVarP(&pkg.ImageCMDOptions.Public, "public-bucket", "p", false, "Cloud Object Storage public bucket.")
	Cmd.Flags().BoolVarP(&pkg.ImageCMDOptions.Watch, "watch", "w", false, "After image import watch for image to be published and ready to use")
	Cmd.Flags().DurationVar(&pkg.ImageCMDOptions.WatchTimeout, "watch-timeout", 1*time.Hour, "watch timeout")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.StorageType, "pvs-storagetype", "tier3", "PowerVS Storage type, accepted values are [tier1, tier3].")
	Cmd.Flags().StringVar(&pkg.ImageCMDOptions.ServiceCredName, "cos-service-cred", "", "IBM COS Service Credential name to be auto generated(default \""+serviceCredPrefix+"-<COS Name>\")")

	_ = Cmd.MarkFlagRequired("bucket")
	_ = Cmd.MarkFlagRequired("bucket-region")
	_ = Cmd.MarkFlagRequired("pvs-image-name")
	_ = Cmd.MarkFlagRequired("object")
	Cmd.Flags().SortFlags = false
}
